# # МОДУЛЬ 8: СИСТЕМА ОБУЧЕНИЯ И АДАПТАЦИИ
# Извлечено из baza.txt (строки 2332-2548)
# Дата создания: 2025-08-29 19:03:09

# МОДУЛЬ 8: СИСТЕМА ОБУЧЕНИЯ И АДАПТАЦИИ

```python
class MLModelTrainer:
    """
    СИСТЕМА МАШИННОГО ОБУЧЕНИЯ ДЛЯ УЛУЧШЕНИЯ КАЧЕСТВА СИГНАЛОВ
    
    ПОДХОДЫ К ОБУЧЕНИЮ:
    1. Supervised Learning - обучение на размеченных исходах сделок
    2. Reinforcement Learning - обучение через reward/penalty торговых результатов  
    3. Online Learning - адаптация к изменяющимся рыночным условиям
    4. Transfer Learning - использование паттернов с одной пары на другой
    """
    
    def __init__(self, config: MLConfig):
        self.feature_extractor = AdvancedFeatureExtractor()
        self.model_ensemble = ModelEnsemble()
        self.performance_validator = CrossValidationEngine()
        
        # === КОНФИГУРАЦИЯ ОБУЧЕНИЯ ===
        self.training_window = config.training_window_days  # 90 дней
        self.validation_split = config.validation_split    # 20%
        self.retraining_frequency = config.retraining_frequency  # каждую неделю
        
    async def extract_features_for_training(self, historical_signals: List[HistoricalSignal]) -> TrainingDataset:
        """
        ИЗВЛЕЧЕНИЕ ПРИЗНАКОВ ДЛЯ ОБУЧЕНИЯ:
        
        ГРУППЫ ПРИЗНАКОВ:
        1. Паттерн-специфичные (FIX размер, RAY качество, импульс сила)
        2. Рыночные (волатильность, тренд, объемы)
        3. Временные (сессия, день недели, праздники)
        4. Макроэкономические (корреляции с традиционными рынками)
        """
        
        features_list = []
        labels_list = []
        
        for signal in historical_signals:
            
            # === ПАТТЕРН ПРИЗНАКИ ===
            pattern_features = {
                # FIX характеристики
                'fix_duration_minutes': signal.fix_duration.total_seconds() / 60,
                'fix_range_atr_ratio': signal.fix_range / signal.atr,
                'fix_touch_count': signal.fix_touch_count,
                'fix_volume_trend': signal.fix_volume_trend,  # убывающий/растущий
                
                # RAY характеристики  
                'ray_validation_strength': signal.ray_validation_strength,
                'ray_test_count': signal.ray_test_count,
                'ray_holding_duration': signal.ray_holding_duration,
                
                # PREFIX качество
                'prefix_retest_quality': signal.prefix_retest_quality,
                'prefix_volume_ratio': signal.prefix_volume_ratio,
                
                # IMPULSE характеристики
                'impulse_volume_surge': signal.impulse_volume_surge,
                'impulse_speed_atr': signal.impulse_speed / signal.atr,
                'impulse_continuation': signal.impulse_continuation_quality
            }
            
            # === РЫНОЧНЫЕ ПРИЗНАКИ ===
            market_features = {
                'atr_percentile': signal.atr_percentile,  # текущий ATR vs история
                'volume_percentile': signal.volume_percentile,
                'trend_strength': signal.trend_strength,
                'trend_duration': signal.trend_duration_hours,
                
                # Структура рынка
                'bid_ask_spread': signal.spread_bps,
                'order_book_depth': signal.order_book_strength,
                'recent_volatility': signal.volatility_regime
            }
            
            # === ВРЕМЕННЫЕ ПРИЗНАКИ ===
            temporal_features = {
                'hour_of_day': signal.timestamp.hour,
                'day_of_week': signal.timestamp.weekday(),
                'trading_session': signal.trading_session_encoded,
                'days_since_weekend': self.days_since_weekend(signal.timestamp),
                
                # Календарные события
                'is_options_expiry': self.is_options_expiry_week(signal.timestamp),
                'is_fomc_week': self.is_fomc_week(signal.timestamp),
                'is_nfp_week': self.is_nfp_week(signal.timestamp)
            }
            
            # === МАКРО ПРИЗНАКИ ===
            macro_features = await self.extract_macro_features(signal)
            
            # Объединяем все признаки
            all_features = {**pattern_features, **market_features, **temporal_features, **macro_features}
            features_list.append(all_features)
            
            # === ЦЕЛЕВАЯ ПЕРЕМЕННАЯ (LABEL) ===
            trade_outcome = signal.trade_outcome
            
            if trade_outcome:
                # Классификация исхода
                if trade_outcome.profit_loss_percent > 0.01:  # >1% прибыль
                    label = 'strong_win'
                elif trade_outcome.profit_loss_percent > 0:
                    label = 'weak_win'
                elif trade_outcome.profit_loss_percent > -0.005:  # убыток <0.5%
                    label = 'small_loss'
                else:
                    label = 'big_loss'
            else:
                label = 'no_outcome'  # сигнал не был использован
                
            labels_list.append(label)
        
        return TrainingDataset(
            features=pd.DataFrame(features_list),
            labels=pd.Series(labels_list),
            metadata={
                'extraction_date': datetime.now(),
                'total_samples': len(features_list),
                'feature_count': len(all_features),
                'class_distribution': pd.Series(labels_list).value_counts().to_dict()
            }
        )
    
    async def train_signal_quality_model(self, dataset: TrainingDataset) -> TrainedModel:
        """
        ОБУЧЕНИЕ МОДЕЛИ ОЦЕНКИ КАЧЕСТВА СИГНАЛОВ:
        
        АРХИТЕКТУРА МОДЕЛИ:
        - Ensemble из XGBoost + LightGBM + Neural Network
        - Каждая модель специализируется на своих аспектах
        - Финальное решение через голосование
        """
        
        X = dataset.features
        y = dataset.labels
        
        # Разделение на train/validation/test
        X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.4, stratify=y)
        X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, stratify=y_temp)
        
        # === МОДЕЛЬ 1: XGBOOST (лучше для паттерн-признаков) ===
        xgb_model = XGBClassifier(
            n_estimators=500,
            max_depth=6,
            learning_rate=0.01,
            subsample=0.8,
            colsample_bytree=0.8,
            reg_alpha=0.1,
            reg_lambda=0.1,
            random_state=42
        )
        
        xgb_model.fit(X_train, y_train, 
                     eval_set=[(X_val, y_val)],
                     early_stopping_rounds=50,
                     verbose=False)
        
        # === МОДЕЛЬ 2: LIGHTGBM (лучше для категориальных признаков) ===
        lgb_model = LGBMClassifier(
            n_estimators=500,
            max_depth=6,
            learning_rate=0.01,
            num_leaves=31,
            subsample=0.8,
            colsample_bytree=0.8,
            reg_alpha=0.1,
            reg_lambda=0.1,
            random_state=42
        )
        
        lgb_model.fit(X_train, y_train,
                     eval_set=[(X_val, y_val)],
                     early_stopping_rounds=50,
                     verbose=False)
        
        # === МОДЕЛЬ 3: NEURAL NETWORK (лучше для сложных взаимодействий) ===
        nn_model = self.create_neural_network(input_dim=X.shape[1])
        nn_model.fit(X_train, y_train,
                    validation_data=(X_val, y_val),
                    epochs=100,
                    batch_size=64,
                    early_stopping=True)
        
        # === СОЗДАНИЕ АНСАМБЛЯ ===
        ensemble = VotingClassifier([
            ('xgb', xgb_model),
            ('lgb', lgb_model), 
            ('nn', nn_model)
        ], voting='soft')  # вероятностное голосование
        
        # === ВАЛИДАЦИЯ НА ТЕСТОВОМ МНОЖЕСТВЕ ===
        test_predictions = ensemble.predict_proba(X_test)
        test_accuracy = accuracy_score(y_test, ensemble.predict(X_test))
        
        # === АНАЛИЗ ВАЖНОСТИ ПРИЗНАКОВ ===
        feature_importance = self.calculate_ensemble_feature_importance(ensemble, X.columns)
        
        return TrainedModel(
            model=ensemble,
            test_accuracy=test_accuracy,
            feature_importance=feature_importance,
            
            # МЕТАДАННЫЕ ОБУЧЕНИЯ
            training_samples=len(X_train),
            validation_samples=len(X_val),
            test_samples=len(X_test),
            training_date=datetime.now(),
            
            # РЕКОМЕНДАЦИИ ПО ИСПОЛЬЗОВАНИЮ
            confidence_threshold=0.7,  # минимальная уверенность для торговли
            recalibration_schedule='weekly',
            expected_drift_detection='monthly'
        )
```
